<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Multi Tool Hub — Image Converter</title>
<link rel="preconnect" href="https://cdnjs.cloudflare.com">
<style>
:root{
  --bg:#0b0f13; --card:#0f1720; --accent:#7c3aed; --muted:#94a3b8; --glass: rgba(255,255,255,0.04);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
body{background:linear-gradient(180deg,#05060a 0%, #07101a 100%); color:#e6eef8; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale}
.container{max-width:980px;margin:28px auto;padding:20px}
.header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
.logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent),#00bcd4);display:flex;align-items:center;justify-content:center;font-weight:700;color:#061421;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
.hgroup h1{margin:0;font-size:20px;letter-spacing:0.2px}
.hgroup p{margin:0;color:var(--muted);font-size:13px}
.card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); padding:18px;border-radius:12px;box-shadow: 0 6px 24px rgba(2,6,23,0.6)}
.grid{display:grid;grid-template-columns:1fr 360px;gap:18px}
@media (max-width:880px){.grid{grid-template-columns:1fr} .header{flex-direction:row}}
.uploader{display:flex;flex-direction:column;gap:12px}
.dropzone{border:2px dashed rgba(255,255,255,0.04);padding:18px;border-radius:10px;background:var(--glass);display:flex;flex-direction:column;align-items:center;gap:10px;cursor:pointer;transition:all .18s}
.dropzone.drag{border-color:rgba(124,58,237,0.9);transform:translateY(-4px)}
.dropzone strong{font-size:13px}
.controls{display:flex;gap:12px;align-items:center}
select, input[type=file]{background:transparent;border:1px solid rgba(255,255,255,0.05);padding:10px 12px;border-radius:10px;color:inherit}
.btn{background:transparent;border:1px solid rgba(255,255,255,0.08);padding:10px 14px;border-radius:10px;color:var(--accent);cursor:pointer;outline:2px solid transparent;transition:transform .12s ease, box-shadow .12s ease}
.btn:active{transform:scale(.98)}
.btn.primary{background:linear-gradient(90deg, rgba(124,58,237,0.14), rgba(0,188,212,0.06));border:1px solid rgba(124,58,237,0.18);color:var(--accent);box-shadow:0 6px 20px rgba(124,58,237,0.08)}
.btn.outline{border:1px solid rgba(255,255,255,0.08)}
.btn-animated{position:relative;overflow:hidden}
.btn-animated::after{content:'';position:absolute;inset:0;border-radius:10px;box-shadow:0 0 0 rgba(124,58,237,0);transition:box-shadow .22s}
.btn-animated:active::after{box-shadow:0 8px 30px rgba(124,58,237,0.12)}
.preview{border-radius:10px;padding:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03)}
.preview img, .preview iframe{max-width:100%;border-radius:8px;display:block}
.meta{color:var(--muted);font-size:13px;margin-top:8px}
.status{margin-top:10px;color:var(--muted);font-size:14px}
.small{font-size:12px;color:var(--muted)}
.footer{margin-top:14px;color:var(--muted);font-size:12px}
.note{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-size:13px}
.filename{font-weight:600}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="logo">MH</div>
    <div class="hgroup">
      <h1>Multi Tool Hub — Image Converter</h1>
      <p>Upload an image and convert it to PNG, JPG, PDF, BMP, WEBP (responsive & client-side)</p>
    </div>
  </div>

  <div class="card">
    <div class="grid">
      <div>
        <div class="uploader">
          <label for="file" class="dropzone" id="dropzone">
            <input id="file" type="file" accept="image/*" style="display:none">
            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" style="opacity:0.9"><path d="M12 3v10" stroke="white" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round" opacity="0.95"/><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" stroke="white" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/><path d="M7 10l5-5 5 5" stroke="white" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round" opacity="0.95"/></svg>
            <strong>Click or drag & drop an image</strong>
            <div class="small">Supported: PNG, JPG, JPEG, BMP, GIF, TIFF*, WEBP — max 10 MB</div>
          </label>

          <div class="controls">
            <select id="format" aria-label="Choose output format">
              <option value="png">PNG</option>
              <option value="jpeg">JPG / JPEG</option>
              <option value="webp">WEBP</option>
              <option value="pdf">PDF</option>
              <option value="bmp">BMP</option>
              <option value="gif">GIF (single-frame)</option>
              <option value="tiff">TIFF (converted as PNG fallback)</option>
            </select>

            <button class="btn primary btn-animated" id="convert">Convert</button>
            <button class="btn outline" id="reset">Reset</button>
          </div>

          <div class="status" id="status">No file selected</div>
          <div class="meta" id="meta"></div>
        </div>

        <div style="margin-top:12px" class="note small">*TIFF and animated GIF conversions are limited by browser support. The tool converts single-frame GIFs and uses PNG fallback for TIFF.</div>
      </div>

      <aside>
        <div class="preview" id="previewCard">
          <div id="previewInner" style="min-height:220px;display:flex;align-items:center;justify-content:center;">Preview will appear here</div>
          <div class="meta" id="outMeta"></div>
          <div style="display:flex;gap:8px;margin-top:12px;align-items:center">
            <a id="downloadBtn" class="btn primary" style="display:none" download>Download</a>
            <button class="btn" id="openBtn" style="display:none">Open</button>
            <div style="flex:1"></div>
            <div class="small">File size: <span id="outSize">-</span></div>
          </div>
        </div>
      </aside>
    </div>

    <div class="footer">Built with Canvas API • Client-side only • Mobile friendly</div>
  </div>
</div>

<!-- jsPDF for PDF export -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('file');
const status = document.getElementById('status');
const meta = document.getElementById('meta');
const previewInner = document.getElementById('previewInner');
const outMeta = document.getElementById('outMeta');
const downloadBtn = document.getElementById('downloadBtn');
const openBtn = document.getElementById('openBtn');
const outSize = document.getElementById('outSize');
const convertBtn = document.getElementById('convert');
const resetBtn = document.getElementById('reset');
const formatSelect = document.getElementById('format');

let currentFile = null;
let convertedBlob = null;
let convertedURL = null;

// Drag & drop
['dragenter','dragover'].forEach(e => {
  dropzone.addEventListener(e, ev => { ev.preventDefault(); dropzone.classList.add('drag'); });
});
['dragleave','drop'].forEach(e => {
  dropzone.addEventListener(e, ev => { ev.preventDefault(); dropzone.classList.remove('drag'); });
});

dropzone.addEventListener('drop', ev => {
  const f = ev.dataTransfer.files && ev.dataTransfer.files[0];
  if (f) handleFile(f);
});

dropzone.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', ()=>{ if (fileInput.files[0]) handleFile(fileInput.files[0]); });
resetBtn.addEventListener('click', resetAll);
convertBtn.addEventListener('click', () => { if (!currentFile) return showError('Please select a file first.'); convert(); });
openBtn.addEventListener('click', ()=> { if (convertedURL) window.open(convertedURL,'_blank'); });

function showError(msg){ status.textContent = msg; status.style.color = '#ff6b6b'; }
function showStatus(msg){ status.textContent = msg; status.style.color = 'var(--muted)'; }

function resetAll(){ currentFile = null; convertedBlob = null; if (convertedURL) URL.revokeObjectURL(convertedURL); convertedURL=null; fileInput.value=''; previewInner.innerHTML='Preview will appear here'; outMeta.textContent=''; outSize.textContent='-'; downloadBtn.style.display='none'; openBtn.style.display='none'; showStatus('No file selected'); }

function handleFile(file){
  const max = 10 * 1024 * 1024; // 10MB
  const allowed = ['image/png','image/jpeg','image/jpg','image/bmp','image/gif','image/tiff','image/webp'];
  if (file.size > max) { showError('File too large — max 10 MB'); return; }
  if (!allowed.includes(file.type) && !file.type.startsWith('image/')) { showError('Unsupported file type'); return; }
  currentFile = file;
  showStatus('File loaded — ready to convert');
  meta.innerHTML = `<div class="filename">${escapeHtml(file.name)}</div><div class="small">Type: ${file.type || 'unknown'} • ${(file.size/1024|0)} KB</div>`;
  renderPreviewFromFile(file);
}

function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

async function renderPreviewFromFile(file){
  const url = URL.createObjectURL(file);
  previewInner.innerHTML = '';
  if (file.type === 'application/pdf'){
    // not expected but in case
    const iframe = document.createElement('iframe'); iframe.src = url; iframe.style.width='100%'; iframe.style.height='260px'; previewInner.appendChild(iframe);
  } else {
    const img = document.createElement('img'); img.src = url; img.alt='Preview'; img.onload = ()=> URL.revokeObjectURL(url);
    previewInner.appendChild(img);
  }
}

async function convert(){
  showStatus('Processing image...');
  const outFormat = formatSelect.value; // png, jpeg, webp, pdf, bmp, gif, tiff
  try{
    const img = await loadImageFromFile(currentFile);
    // draw to canvas (fit to max dimensions)
    const maxDim = 2480; // for PDF/A4 safety and mobile
    let {canvas, ctx} = drawToCanvas(img, maxDim);

    if (outFormat === 'pdf'){
      // use jsPDF
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({unit:'pt',format:[canvas.width, canvas.height]});
      const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
      pdf.addImage(dataUrl, 'JPEG', 0, 0, canvas.width, canvas.height);
      const blob = pdf.output('blob');
      finishConversion(blob, `${stripExt(currentFile.name)}.pdf`, 'application/pdf');
      return;
    }

    // For image formats, use toBlob where possible
    if (['png','jpeg','webp'].includes(outFormat)){
      const mime = outFormat === 'jpeg' ? 'image/jpeg' : (outFormat === 'webp' ? 'image/webp' : 'image/png');
      canvas.toBlob(blob => {
        if (!blob) { showError('Conversion failed'); return; }
        finishConversion(blob, `${stripExt(currentFile.name)}.${outFormat === 'jpeg'? 'jpg': outFormat}`, mime);
      }, mime, outFormat==='jpeg'?0.92:0.92);
      return;
    }

    if (outFormat === 'bmp'){
      const bmpBlob = canvasToBMP(canvas);
      finishConversion(bmpBlob, `${stripExt(currentFile.name)}.bmp`, 'image/bmp');
      return;
    }

    if (outFormat === 'gif'){
      // Convert single-frame GIF by exporting PNG and renaming to .gif (animated GIF not supported)
      canvas.toBlob(blob => {
        finishConversion(blob, `${stripExt(currentFile.name)}.gif`, 'image/gif');
      }, 'image/png');
      return;
    }

    if (outFormat === 'tiff'){
      // Browsers don't support TIFF encoding client-side reliably. Provide PNG fallback and notify user.
      canvas.toBlob(blob => {
        finishConversion(blob, `${stripExt(currentFile.name)}.tiff`, 'image/png', true);
      }, 'image/png');
      return;
    }

    showError('Unsupported output format');
  }catch(err){
    console.error(err);
    showError('Error processing image');
  }
}

function finishConversion(blob, filename, mime, isTiffFallback=false){
  if (convertedURL) URL.revokeObjectURL(convertedURL);
  convertedBlob = blob;
  convertedURL = URL.createObjectURL(blob);
  downloadBtn.href = convertedURL;
  downloadBtn.download = filename;
  downloadBtn.style.display = 'inline-block';
  openBtn.style.display = 'inline-block';
  outSize.textContent = humanFileSize(blob.size);
  outMeta.textContent = `Output: ${filename} • ${mime}${isTiffFallback? ' (TIFF requested — PNG fallback used due to browser limits)':''}`;

  // preview
  previewInner.innerHTML = '';
  if (mime === 'application/pdf'){
    const iframe = document.createElement('iframe'); iframe.src = convertedURL; iframe.style.width='100%'; iframe.style.height='320px'; previewInner.appendChild(iframe);
  } else {
    const img = document.createElement('img'); img.src = convertedURL; img.alt='Converted preview'; img.onload = ()=> URL.revokeObjectURL(convertedURL);
    previewInner.appendChild(img);
  }
  showStatus('Conversion complete');
}

function humanFileSize(bytes){ const thresh = 1024; if (Math.abs(bytes) < thresh) return bytes + ' B'; const units = ['KB','MB','GB','TB']; let u = -1; do { bytes /= thresh; ++u; } while(Math.abs(bytes) >= thresh && u < units.length-1); return bytes.toFixed(1)+' '+units[u]; }

function stripExt(name){ return name.replace(/\.[^/.]+$/, ""); }

function loadImageFromFile(file){
  return new Promise((res, rej)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{ URL.revokeObjectURL(url); res(img); };
    img.onerror = e => { URL.revokeObjectURL(url); rej(e); };
    img.src = url;
  });
}

function drawToCanvas(img, maxDim){
  const ratio = img.width / img.height;
  let width = img.width, height = img.height;
  if (Math.max(width, height) > maxDim){
    if (width > height){ width = maxDim; height = Math.round(maxDim / ratio); }
    else { height = maxDim; width = Math.round(maxDim * ratio); }
  }
  const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
  const ctx = canvas.getContext('2d');
  // fill with transparent or white depending on original
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // Draw with high quality
  ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  return {canvas, ctx};
}

// Simple Canvas -> BMP encoder (uncompressed 24-bit BMP)
function canvasToBMP(canvas){
  const width = canvas.width; const height = canvas.height;
  const ctx = canvas.getContext('2d');
  const imageData = ctx.getImageData(0,0,width,height);
  const pixels = imageData.data;
  const rowBytes = Math.floor((24*width + 31)/32)*4; // rows aligned to 4 bytes
  const pixelArraySize = rowBytes * height;
  const headerSize = 54; // 14 + 40
  const fileSize = headerSize + pixelArraySize;

  const buffer = new ArrayBuffer(fileSize);
  const view = new DataView(buffer);
  let offset = 0;
  // BITMAPFILEHEADER
  view.setUint8(offset, 0x42); offset++; view.setUint8(offset,0x4D); offset++; // 'BM'
  view.setUint32(offset, fileSize, true); offset += 4;
  view.setUint16(offset, 0, true); offset += 2;
  view.setUint16(offset, 0, true); offset += 2;
  view.setUint32(offset, headerSize, true); offset += 4;
  // BITMAPINFOHEADER
  view.setUint32(offset, 40, true); offset += 4; // header size
  view.setInt32(offset, width, true); offset += 4;
  view.setInt32(offset, height, true); offset += 4;
  view.setUint16(offset, 1, true); offset += 2; // planes
  view.setUint16(offset, 24, true); offset += 2; // bits per pixel
  view.setUint32(offset, 0, true); offset += 4; // compression
  view.setUint32(offset, pixelArraySize, true); offset += 4; // image size
  view.setInt32(offset, 2835, true); offset += 4; // x pixels per meter (72 DPI)
  view.setInt32(offset, 2835, true); offset += 4; // y
  view.setUint32(offset, 0, true); offset += 4; // colors
  view.setUint32(offset, 0, true); offset += 4; // important colors

  // Pixel data (BGR bottom-up)
  const pixelDataOffset = headerSize;
  let p = pixelDataOffset;
  const padding = rowBytes - width * 3;
  for (let y = height - 1; y >= 0; y--){
    for (let x = 0; x < width; x++){
      const idx = (y*width + x) * 4;
      const r = pixels[idx]; const g = pixels[idx+1]; const b = pixels[idx+2]; // ignore alpha
      view.setUint8(p++, b);
      view.setUint8(p++, g);
      view.setUint8(p++, r);
    }
    // padding
    for (let k = 0; k < padding; k++) view.setUint8(p++, 0);
  }

  return new Blob([buffer], {type: 'image/bmp'});
}

</script>
</body>
</html>
